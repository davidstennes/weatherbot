<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>WeatherBot</title>

  <style>
    body {
      margin: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont,
        "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
      background: #ffffff;
      color: #111;
    }

    /* =====================
       HERO HEADER
       ===================== */
    .wb-hero {
      padding: 1.6rem 1rem 1.1rem;
      text-align: center;
    }

    .wb-hero-row {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 0.75rem;
    }

    .wb-title {
      margin: 0;
      font-size: clamp(1.65rem, 5.2vw, 2.15rem);
      font-weight: 600;
      line-height: 1.18;
      max-width: 22rem;
    }

    .wb-icon {
      font-size: 1.45rem;
      opacity: 0.8;
      user-select: none;
    }

    .wb-left { transform: translateY(0.08em); }
    .wb-right { transform: translateY(0.04em); }

    .wb-subtitle {
      margin-top: 0.45rem;
      font-size: 0.95rem;
      opacity: 0.72;
    }

    /* =====================
       CARD ROW
       ===================== */
    .card-row {
      display: flex;
      gap: 0.75rem;
      padding: 1.25rem 1rem 2rem;
      justify-content: center;
      align-items: flex-start;
    }

    .card {
      border: 2px solid #e0e0e0;
      border-radius: 18px;
      background: #fff;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      color: #555;
    }

    /* Left city card (short) */
    .card.city {
      width: 140px;
      height: 70px;
      justify-content: center;
      padding: 0.25rem 0.5rem;
      position: relative;
    }

    .city-input {
      width: 100%;
      height: 42px;
      border: 0;
      outline: none;
      font-size: 16px; /* prevents mobile zoom */
      padding: 0 0.75rem;
      border-radius: 14px;
      background: transparent;
      color: #111;
    }

    .city-input::placeholder {
      color: #777;
    }

    /* Autocomplete dropdown */
    .suggestions {
      position: absolute;
      left: 0;
      right: 0;
      top: 74px;
      margin: 0 auto;
      width: 260px;
      max-width: calc(100vw - 2rem);
      border: 1px solid #e6e6e6;
      border-radius: 14px;
      background: #fff;
      box-shadow: 0 10px 30px rgba(0,0,0,0.08);
      overflow: hidden;
      display: none;
      z-index: 50;
    }

    .suggestions button {
      width: 100%;
      border: 0;
      background: #fff;
      padding: 0.65rem 0.75rem;
      text-align: left;
      font-size: 15px;
      color: #111;
    }

    .suggestions button:active {
      background: #f5f5f5;
    }

    .suggestions .sub {
      display: block;
      font-size: 12px;
      opacity: 0.65;
      margin-top: 2px;
    }

    /* Day cards (tall) */
    .card.day {
      width: 90px;
      height: 165px;
      padding: 0.6rem 0.5rem 0.5rem;
      gap: 0.35rem;
      align-items: center;
    }

    .dow {
      font-weight: 600;
      color: #777;
      margin-top: 0.1rem;
    }

    .temps {
      margin-top: 0.65rem;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 0.25rem;
      color: #111;
    }

    .hi {
      font-size: 1.35rem;
      font-weight: 700;
      line-height: 1;
    }

    .lo {
      font-size: 1.05rem;
      font-weight: 600;
      opacity: 0.55;
      line-height: 1;
    }

    .muted {
      opacity: 0.6;
      font-size: 0.9rem;
    }

    .status {
      text-align: center;
      margin-top: -0.65rem;
      font-size: 0.9rem;
      opacity: 0.65;
      min-height: 1.25rem;
      padding: 0 1rem;
    }
  </style>
</head>

<body>

  <!-- HERO -->
  <header class="wb-hero">
    <div class="wb-hero-row">
      <span class="wb-icon wb-left" aria-hidden="true">üå¥</span>
      <h1 class="wb-title">Where is the weather better?</h1>
      <span class="wb-icon wb-right" aria-hidden="true">‚õ∑Ô∏è</span>
    </div>

    <div class="wb-subtitle">Compare up to five places side by side.</div>
  </header>

  <div id="status" class="status"></div>

  <!-- ROW -->
  <section class="card-row">
    <!-- City / autocomplete box -->
    <div class="card city">
      <input id="cityInput" class="city-input" type="text" placeholder="Add city" autocomplete="off" />
      <div id="suggestions" class="suggestions" role="listbox" aria-label="City suggestions"></div>
    </div>

    <!-- 3-day boxes -->
    <div class="card day" id="day0">
      <div class="dow" id="dow0">‚Äî</div>
      <div class="temps">
        <div class="hi" id="hi0">‚Äî</div>
        <div class="lo" id="lo0">‚Äî</div>
      </div>
      <div class="muted" id="meta0"></div>
    </div>

    <div class="card day" id="day1">
      <div class="dow" id="dow1">‚Äî</div>
      <div class="temps">
        <div class="hi" id="hi1">‚Äî</div>
        <div class="lo" id="lo1">‚Äî</div>
      </div>
      <div class="muted" id="meta1"></div>
    </div>

    <div class="card day" id="day2">
      <div class="dow" id="dow2">‚Äî</div>
      <div class="temps">
        <div class="hi" id="hi2">‚Äî</div>
        <div class="lo" id="lo2">‚Äî</div>
      </div>
      <div class="muted" id="meta2"></div>
    </div>
  </section>

  <script>
    const cityInput = document.getElementById("cityInput");
    const suggestionsEl = document.getElementById("suggestions");
    const statusEl = document.getElementById("status");

    let debounceTimer = null;
    let activeResults = [];
    let lastQuery = "";

    function setStatus(msg) {
      statusEl.textContent = msg || "";
    }

    function showSuggestions(show) {
      suggestionsEl.style.display = show ? "block" : "none";
    }

    function fmtWeekday(dateStr) {
      // dateStr like "2026-01-24"
      const d = new Date(dateStr + "T12:00:00");
      return new Intl.DateTimeFormat(undefined, { weekday: "short" }).format(d);
    }

    function fmtTemp(n) {
      if (n === null || n === undefined || Number.isNaN(n)) return "‚Äî";
      return Math.round(n) + "¬∞";
    }

    function clearDayCards() {
      for (let i = 0; i < 3; i++) {
        document.getElementById(`dow${i}`).textContent = "‚Äî";
        document.getElementById(`hi${i}`).textContent = "‚Äî";
        document.getElementById(`lo${i}`).textContent = "‚Äî";
        document.getElementById(`meta${i}`).textContent = "";
      }
    }

    function renderSuggestions(results) {
      suggestionsEl.innerHTML = "";
      if (!results.length) {
        showSuggestions(false);
        return;
      }

      results.slice(0, 8).forEach((r, idx) => {
        const btn = document.createElement("button");
        btn.type = "button";
        btn.setAttribute("role", "option");

        const primary = `${r.name}${r.admin1 ? ", " + r.admin1 : ""}${r.country ? ", " + r.country : ""}`;
        const secondary = `(${r.latitude.toFixed(3)}, ${r.longitude.toFixed(3)})`;

        btn.innerHTML = `${primary}<span class="sub">${secondary}</span>`;
        btn.addEventListener("click", () => {
          selectCity(r);
        });

        suggestionsEl.appendChild(btn);
      });

      showSuggestions(true);
    }

    async function geocodeCities(query) {
      // Open-Meteo Geocoding API (free)
      const url = new URL("https://geocoding-api.open-meteo.com/v1/search");
      url.searchParams.set("name", query);
      url.searchParams.set("count", "8");
      url.searchParams.set("language", "en");
      url.searchParams.set("format", "json");

      const res = await fetch(url.toString());
      if (!res.ok) throw new Error("Geocoding failed");
      const data = await res.json();
      return data.results || [];
    }

    async function fetch3DayForecast(lat, lon) {
      // Open-Meteo Forecast API (free)
      const url = new URL("https://api.open-meteo.com/v1/forecast");
      url.searchParams.set("latitude", lat);
      url.searchParams.set("longitude", lon);
      url.searchParams.set("daily", "temperature_2m_max,temperature_2m_min");
      url.searchParams.set("timezone", "auto");

      const res = await fetch(url.toString());
      if (!res.ok) throw new Error("Forecast failed");
      const data = await res.json();
      return data;
    }

    function fillDayCardsFromForecast(forecast) {
      const daily = forecast.daily;
      if (!daily || !daily.time || daily.time.length < 3) {
        throw new Error("Not enough daily data");
      }

      // We trust Open-Meteo's daily.time order: it begins "today" in the chosen timezone.
      for (let i = 0; i < 3; i++) {
        const dateStr = daily.time[i];
        const dow = fmtWeekday(dateStr);
        const hi = fmtTemp(daily.temperature_2m_max[i]);
        const lo = fmtTemp(daily.temperature_2m_min[i]);

        document.getElementById(`dow${i}`).textContent = dow;
        document.getElementById(`hi${i}`).textContent = hi;
        document.getElementById(`lo${i}`).textContent = lo;
        document.getElementById(`meta${i}`).textContent = ""; // reserved for wind/icons later
      }
    }

    async function selectCity(city) {
      // Lock input text to selected city
      const label = `${city.name}${city.admin1 ? ", " + city.admin1 : ""}${city.country ? ", " + city.country : ""}`;
      cityInput.value = label;
      showSuggestions(false);
      activeResults = [];

      setStatus("Loading forecast‚Ä¶");
      clearDayCards();

      try {
        const forecast = await fetch3DayForecast(city.latitude, city.longitude);
        fillDayCardsFromForecast(forecast);
        setStatus("");
      } catch (e) {
        console.error(e);
        setStatus("Couldn‚Äôt load forecast for that city.");
      }
    }

    // Close suggestions on outside tap
    document.addEventListener("click", (e) => {
      const within = e.target === cityInput || suggestionsEl.contains(e.target);
      if (!within) showSuggestions(false);
    });

    cityInput.addEventListener("input", () => {
      const q = cityInput.value.trim();
      if (q.length < 2) {
        showSuggestions(false);
        setStatus("");
        return;
      }

      // debounce
      clearTimeout(debounceTimer);
      debounceTimer = setTimeout(async () => {
        try {
          lastQuery = q;
          const results = await geocodeCities(q);

          // If user typed something else while we awaited:
          if (cityInput.value.trim() !== lastQuery) return;

          activeResults = results;
          renderSuggestions(results);
          setStatus("");
        } catch (e) {
          console.error(e);
          showSuggestions(false);
          setStatus("Autocomplete unavailable.");
        }
      }, 250);
    });

    // Optional: Enter chooses first suggestion if dropdown open
    cityInput.addEventListener("keydown", (e) => {
      if (e.key === "Enter" && activeResults.length) {
        e.preventDefault();
        selectCity(activeResults[0]);
      }
      if (e.key === "Escape") {
        showSuggestions(false);
      }
    });

    // Initialize weekday labels to today/tomorrow/next, even before selecting a city.
    // (Forecast fill will overwrite once city selected.)
    (function initDows() {
      const now = new Date();
      for (let i = 0; i < 3; i++) {
        const d = new Date(now);
        d.setDate(now.getDate() + i);
        const dow = new Intl.DateTimeFormat(undefined, { weekday: "short" }).format(d);
        document.getElementById(`dow${i}`).textContent = dow;
      }
    })();
  </script>

</body>
</html>
