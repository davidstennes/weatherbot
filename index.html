<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>No Bad Days</title>

<style>
:root{
  --bg:#f5f6f8;
  --card:#ffffff;
  --text:#111;
  --muted:#6b7280;
  --border:#d1d5db;
  --wind-calm:#cbd5e1;
  --wind-breezy:#3b82f6;
  --wind-strong:#1e40af;
  --gust:#dc2626;
}

*{box-sizing:border-box}

body{
  margin:0;
  font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif;
  background:var(--bg);
  color:var(--text);
}

header{
  padding:18px 16px 8px;
  text-align:center;
  position:relative;
}

.hero{
  max-width:1100px;
  margin:0 auto;
  display:grid;
  grid-template-columns:60px 1fr 60px;
  align-items:center;
}
.hero .emoji{
  font-size:28px;
  opacity:.9;
  display:flex;
  align-items:center;
  justify-content:center; /* centers icons */
}
.hero h1{
  margin:0;
  font-size:28px;
  font-weight:900;
}
.hero p{
  margin:6px 0 0;
  color:var(--muted);
  font-size:14px;
  font-style:italic;
}

main{
  max-width:1100px;
  margin:0 auto;
  padding:12px 12px 24px;
}

.card{
  background:var(--card);
  border:1px solid var(--border);
  border-radius:18px;
  padding:14px;
  overflow:hidden;
}

/* Header above inputs */
.inputsHeader{
  text-align:center;         /* centered per your arrows */
  margin-bottom:6px;
}
.inputsHeader .title{
  font-weight:900;
}
.inputsHeader .sub{
  color:var(--muted);
  font-size:12px;
}

/* Dynamic title centered over the day columns (not the city column) */
.forecastTitleRow{
  display:grid;
  grid-template-columns:180px 1fr; /* match city column width */
  align-items:center;
  margin:8px 0 6px;
}
.forecastTitle{
  text-align:center;
  font-weight:900;
}

/* Grid */
.grid{
  display:grid;
  gap:10px;
  align-items:center;
}

/* City column */
.cityWrap{
  display:flex;
  flex-direction:column;
  gap:4px;
}
.cityInput{
  padding:10px 12px;
  border:1px solid var(--border);
  border-radius:12px;
  font-size:15px;
}
.cityConfirm{
  text-align:center;
  font-size:12px;
  color:var(--muted);
  min-height:14px;
}
.cityLink{
  text-align:center;
  font-size:12px;
  min-height:14px;
}
.cityLink a{
  color:#2563eb;
  text-decoration:none;
}
.cityLink a:hover{ text-decoration:underline; }

/* Days */
.day{
  text-align:center;
  font-size:13px;
  font-weight:800;
  color:var(--muted);
}

/* Cells */
.cell{
  border:1px solid var(--border);
  border-radius:14px;
  min-height:86px;
  display:flex;
  flex-direction:column;
  align-items:center;
  justify-content:center;
  gap:2px;
  position:relative;
}
.wxIcon{ font-size:22px; line-height:1; }
.windRow{
  display:flex;
  align-items:center;
  justify-content:center;
  gap:4px;
}
.windIcon svg{ width:18px; height:18px; display:block; }
.windNum{ font-size:11px; color:var(--muted); }
.hi{ font-weight:900; }
.lo{ font-size:12px; color:var(--muted); }

/* Gust triangle */
.gust{
  position:absolute;
  top:6px;
  right:6px;
  width:0;height:0;
  border-left:6px solid transparent;
  border-right:6px solid transparent;
  border-bottom:10px solid var(--gust);
}

/* Legend */
.legend{
  display:flex;
  gap:12px;
  flex-wrap:wrap;
  align-items:center;
  margin-top:10px;
  color:var(--muted);
  font-size:12px;
}
.legend .item{ display:flex; align-items:center; gap:6px; }
.legend .tri{
  width:0;height:0;
  border-left:6px solid transparent;
  border-right:6px solid transparent;
  border-bottom:10px solid var(--gust);
}

/* Responsive columns */
@media (orientation:portrait){
  .grid{ grid-template-columns:180px repeat(3,1fr); }
  .forecastTitleRow{ grid-template-columns:180px 1fr; }
}
@media (orientation:landscape){
  .grid{ grid-template-columns:180px repeat(5,1fr); }
  .forecastTitleRow{ grid-template-columns:180px 1fr; }
}
</style>
</head>

<body>

<header>
  <div class="hero">
    <div class="emoji">üå¥</div>
    <div>
      <h1>No Bad Days</h1>
      <p>‚ÄúCheck the weather before you go.‚Äù</p>
    </div>
    <div class="emoji">‚õ∑Ô∏è</div>
  </div>
</header>

<main>
  <div class="card">

    <div class="inputsHeader">
      <div class="title">Enter cities</div>
      <div class="sub">(up to five)</div>
    </div>

    <div class="forecastTitleRow">
      <div></div>
      <div id="title" class="forecastTitle">At a glance</div>
    </div>

    <div class="grid" id="grid"></div>

    <div class="legend">
      <div class="item"><span style="color:var(--wind-calm)">‚óè</span> Calm ‚â§ 5 mph</div>
      <div class="item"><span style="color:var(--wind-breezy)">‚óè</span> Breezy 6‚Äì15 mph</div>
      <div class="item"><span style="color:var(--wind-strong)">‚óè</span> Strong ‚â• 16 mph</div>
      <div class="item"><span class="tri"></span> Gusty (gusts ‚â• 1.8√ó sustained)</div>
    </div>

  </div>
</main>

<datalist id="cities"></datalist>

<script>
const grid = document.getElementById("grid");
const title = document.getElementById("title");
const datalist = document.getElementById("cities");

const cToF = c => Math.round(c * 9/5 + 32);
const mph = ms => Math.round(ms * 2.23694);

const windSVG = (stroke)=>`
<svg viewBox="0 0 24 24" fill="none" stroke="${stroke}"
 stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
 <path d="M3 8h10a3 3 0 1 0-3-3"/>
 <path d="M2 12h14a3 3 0 1 1-3 3"/>
 <path d="M4 16h6"/>
</svg>`;

function wxIcon(code){
  if(code === 0) return "‚òÄÔ∏è";
  if(code <= 2) return "üå§Ô∏è";
  if(code === 3) return "‚òÅÔ∏è";
  if(code >= 51 && code <= 67) return "üåßÔ∏è";
  if(code >= 71 && code <= 77) return "üå®Ô∏è";
  if(code >= 95) return "‚õàÔ∏è";
  return "üå°Ô∏è";
}

function daysCount(){
  return matchMedia("(orientation:landscape)").matches ? 5 : 3;
}

function updateTitle(n){
  title.textContent = `${n}-day at a glance`;
}

async function geocode(q){
  const r = await fetch(
    "https://geocoding-api.open-meteo.com/v1/search?count=6&language=en&name="+encodeURIComponent(q)
  );
  const j = await r.json();
  return j.results || [];
}

async function forecast(lat,lon,days){
  const r = await fetch(
    `https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lon}`+
    `&daily=temperature_2m_max,temperature_2m_min,weathercode,windspeed_10m_max,windgusts_10m_max`+
    `&forecast_days=${days}&timezone=auto`
  );
  return await r.json();
}

function windStroke(maxMph){
  if(maxMph <= 5) return getComputedStyle(document.documentElement).getPropertyValue('--wind-calm').trim();
  if(maxMph <= 15) return getComputedStyle(document.documentElement).getPropertyValue('--wind-breezy').trim();
  return getComputedStyle(document.documentElement).getPropertyValue('--wind-strong').trim();
}

// Gust rule A (locked): gust >= 1.8√ó sustained AND gust >= 18 mph
function isGusty(sustainedMaxMph, gustMph){
  return (gustMph >= sustainedMaxMph * 1.8) && (gustMph >= 18);
}

function headerDays(n){
  const now = new Date();
  const days = [];
  for(let i=0;i<n;i++){
    const d = new Date(now);
    d.setDate(now.getDate()+i);
    days.push(d.toLocaleDateString(undefined,{weekday:'short'}));
  }
  return days;
}

/* ---------- state (so we can rebuild ONLY when needed) ---------- */
let currentN = null;
const rows = []; // each row stores references + state

function clearGrid(){
  grid.innerHTML = "";
}

function makePlaceholder(i){
  // You asked specifically: City 2 should say City 2 (optional)
  // Keeping City 1 required, City 2 optional, City 3‚Äì5 optional.
  if(i === 1) return "City 1";
  return `City ${i} (optional)`;
}

function buildStructure(n){
  clearGrid();
  updateTitle(n);

  // header row
  grid.appendChild(document.createElement("div"));
  headerDays(n).forEach(d=>{
    const el = document.createElement("div");
    el.className = "day";
    el.textContent = d;
    grid.appendChild(el);
  });

  rows.length = 0;

  for(let i=1;i<=5;i++){
    const city = document.createElement("div");
    city.className="cityWrap";
    city.innerHTML=`
      <input class="cityInput" list="cities" placeholder="${makePlaceholder(i)}" spellcheck="false" autocapitalize="words">
      <div class="cityConfirm"></div>
      <div class="cityLink"></div>
    `;
    grid.appendChild(city);

    const cells=[];
    for(let d=0; d<n; d++){
      const c=document.createElement("div");
      c.className="cell";
      c.textContent="‚Äî";
      grid.appendChild(c);
      cells.push(c);
    }

    const input = city.querySelector(".cityInput");
    const confirm = city.querySelector(".cityConfirm");
    const link = city.querySelector(".cityLink");

    const rowState = {
      input, confirm, link, cells,
      // keep resolved city
      place: null, // {name, admin1, country_code, latitude, longitude}
      // keep last wx data
      wx: null
    };

    // autocomplete suggestions (city-only list)
    let debounce;
    input.addEventListener("input",()=>{
      clearTimeout(debounce);
      const q = input.value.trim();
      if(q.length < 3) return;
      debounce = setTimeout(async()=>{
        const res = await geocode(q);
        datalist.innerHTML="";
        res.forEach(r=>{
          const o=document.createElement("option");
          o.value=r.name;
          datalist.appendChild(o);
        });
        // live guess line under input (top match)
        if(res.length){
          const g=res[0];
          rowState.confirm.textContent = formatPlace(g);
        }
      }, 220);
    });

    input.addEventListener("change", async()=>{
      const q=input.value.trim();
      if(!q) return;

      const res=await geocode(q);
      if(!res.length) return;

      const g=res[0];
      rowState.place = g;
      input.value = g.name;

      confirm.textContent = formatPlace(g);
      link.innerHTML = `üìç <a target="_blank" rel="noopener"
        href="https://www.google.com/search?q=${encodeURIComponent("things to do in " + g.name)}">
        Things to do in ${g.name}</a>`;

      // fetch forecast for current day count
      rowState.wx = await forecast(g.latitude, g.longitude, currentN);
      renderRow(rowState);
    });

    rows.push(rowState);
  }
}

function formatPlace(g){
  const name = g?.name || "";
  const admin1 = g?.admin1 || "";
  const cc = g?.country_code || "";
  if(!name) return "";
  if(cc === "US"){
    return admin1 ? `${name}, ${admin1}` : name;
  }
  // non-US: include country code so it's clear
  const parts = [name];
  if(admin1) parts.push(admin1);
  if(cc) parts.push(cc);
  return parts.join(", ");
}

function renderRow(row){
  const n = currentN;
  const cells = row.cells;

  // ensure cells count matches (rebuild scenario handled elsewhere)
  if(!row.wx || !row.wx.daily) return;

  for(let d=0; d<n; d++){
    const maxWind = mph(row.wx.daily.windspeed_10m_max[d]);
    const gust = mph(row.wx.daily.windgusts_10m_max[d]);
    const stroke = windStroke(maxWind);

    cells[d].innerHTML = `
      ${isGusty(maxWind, gust) ? '<span class="gust" title="Gusty"></span>' : ''}
      <div class="wxIcon">${wxIcon(row.wx.daily.weathercode[d])}</div>
      <div class="windRow">
        <span class="windIcon">${windSVG(stroke)}</span>
        <span class="windNum">${maxWind}</span>
      </div>
      <div class="hi">${cToF(row.wx.daily.temperature_2m_max[d])}¬∞</div>
      <div class="lo">${cToF(row.wx.daily.temperature_2m_min[d])}¬∞</div>
    `;
  }
}

/* Rebuild ONLY when day count changes (portrait 3 ‚Üî landscape 5) */
async function rebuildIfNeeded(){
  const n = daysCount();
  if(currentN === n) return;         // no rebuild: prevents the flashing/typing bomb
  currentN = n;

  // capture existing inputs/places
  const snapshot = rows.map(r=>({
    typed: r.input?.value || "",
    place: r.place,
    wx: r.wx
  }));

  buildStructure(n);

  // restore
  snapshot.forEach((s, idx)=>{
    const r = rows[idx];
    if(!r) return;

    // restore typed text
    r.input.value = s.typed || "";

    // restore place + link + confirm + data if we had it
    if(s.place){
      r.place = s.place;
      r.confirm.textContent = formatPlace(s.place);
      r.link.innerHTML = `üìç <a target="_blank" rel="noopener"
        href="https://www.google.com/search?q=${encodeURIComponent("things to do in " + s.place.name)}">
        Things to do in ${s.place.name}</a>`;
    }

    // if we had wx data, refetch to match new day count
    if(s.place){
      // refetch on resize/orientation change so days align
      forecast(s.place.latitude, s.place.longitude, currentN).then(wx=>{
        r.wx = wx;
        renderRow(r);
      });
    }
  });
}

/* init */
currentN = daysCount();
buildStructure(currentN);

/* Only listen for actual orientation/day-count changes */
const mq = matchMedia("(orientation:landscape)");
mq.addEventListener?.("change", rebuildIfNeeded);
// Fallback for browsers without addEventListener on MediaQueryList
mq.addListener?.(rebuildIfNeeded);

// Also guard against rare cases where orientation doesn't fire but day-count changes:
window.addEventListener("resize", ()=>{
  // debounce + only rebuild if day-count differs
  clearTimeout(window.__wbResizeT);
  window.__wbResizeT = setTimeout(rebuildIfNeeded, 120);
});
</script>

</body>
</html>
