<script>
const grid = document.getElementById("grid");
const title = document.getElementById("title");
const datalist = document.getElementById("cities");

const mph = v => Math.round(v); // we request mph from API

/* Your wind icon (restored), converted to currentColor fill so we can shade it */
const windSVG = `
<svg viewBox="0 0 256 256" xmlns="http://www.w3.org/2000/svg" aria-hidden="true">
  <g fill="currentColor">
    <path d="m174.8,161.7c0,14.5 11.8,26.2 26.2,26.2s26.2-11.8 26.2-26.2-11.8-26.2-26.2-26.2l-191,0"/>
    <path d="m193.6,83c0-14.5 11.8-26.2 26.2-26.2s26.2 11.8 26.2 26.2-11.8 26.2-26.2 26.2l-209.8,0"/>
    <path d="m111.1,180.4c0,10.3 8.4,18.7 18.7,18.7s18.7-8.4 18.7-18.7-8.4-18.7-18.7-18.7l-119.8,0"/>
  </g>
</svg>`;

// wind color banding (tile number is "typical daytime sustained mph")
function windColor(maxMph){
  const root = getComputedStyle(document.documentElement);
  if(maxMph <= 5) return root.getPropertyValue('--wind-calm').trim();
  if(maxMph <= 15) return root.getPropertyValue('--wind-breezy').trim();
  return root.getPropertyValue('--wind-strong').trim();
}

// Gust rule A (locked)
function isGusty(sustainedMph, gustMph){
  return (gustMph >= sustainedMph * 1.8) && (gustMph >= 18);
}

// portrait 3 / landscape 7
function daysCount(){
  return matchMedia("(orientation:landscape)").matches ? 7 : 3;
}

function updateTitle(n){
  title.textContent = `${n}-day at a glance`;
}

async function geocode(q){
  const r = await fetch(
    "https://geocoding-api.open-meteo.com/v1/search?count=6&language=en&name="+encodeURIComponent(q)
  );
  const j = await r.json();
  return j.results || [];
}

/**
 * FULL DROP forecast:
 * - temps from DAILY (reliable)
 * - icon + wind from HOURLY (meteorologically "what it looks/feels like")
 * - lock units: Fahrenheit + mph
 */
async function forecast(lat, lon, days){
  const url =
    `https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lon}` +
    `&timezone=auto&forecast_days=${days}` +
    `&temperature_unit=fahrenheit&wind_speed_unit=mph` +
    `&daily=temperature_2m_max,temperature_2m_min,time` +
    `&hourly=time,weather_code,cloud_cover,precipitation_probability,precipitation,` +
    `windspeed_10m,windgusts_10m,is_day`;
  const r = await fetch(url);
  return await r.json();
}

function groupHourlyByDay(wx){
  const map = new Map();
  const times = wx.hourly.time; // local time because timezone=auto
  for(let i=0;i<times.length;i++){
    const day = times[i].slice(0,10);
    if(!map.has(day)) map.set(day, []);
    map.get(day).push(i);
  }
  return map;
}

// pick representative hour: 13:00 local, else first daytime, else first
function pickRepHourIndex(wx, dayISO){
  const idxs = wx.__dayMap.get(dayISO) || [];
  if(!idxs.length) return null;

  for(const i of idxs){
    if(wx.hourly.time[i].slice(11,13) === "13") return i;
  }
  for(const i of idxs){
    if(wx.hourly.is_day?.[i] === 1) return i;
  }
  return idxs[0];
}

function median(arr){
  const a = arr.slice().sort((x,y)=>x-y);
  if(!a.length) return null;
  const m = Math.floor(a.length/2);
  return a.length % 2 ? a[m] : (a[m-1] + a[m]) / 2;
}

/**
 * Cloud/sun truth source:
 * If dry at representative hour, choose icon by cloud_cover percent.
 * This fixes "everything shows clouds" caused by daily weathercode summaries.
 */
function wxIconFromHourly(code, cloudPct, precipMm, precipProb, isDay){
  if(code >= 95) return "‚õàÔ∏è";
  if((code >= 71 && code <= 77) || (code >= 85 && code <= 86)) return "üå®Ô∏è";
  if(code === 45 || code === 48) return "üå´Ô∏è";

  const precipy = (precipMm != null && precipMm >= 0.1) || (precipProb != null && precipProb >= 40);
  if(precipy){
    if(code >= 51 && code <= 57) return "üå¶Ô∏è";
    return "üåßÔ∏è";
  }

  // Dry: decide by cloud cover (key fix)
  if(cloudPct == null){
    if(code === 0) return "‚òÄÔ∏è";
    if(code === 1) return "üå§Ô∏è";
    if(code === 2) return "‚õÖ";
    if(code === 3) return "‚òÅÔ∏è";
    return "‚òÄÔ∏è";
  }

  if(cloudPct <= 25) return isDay ? "‚òÄÔ∏è" : "üåô";
  if(cloudPct <= 60) return "üå§Ô∏è";
  if(cloudPct <= 85) return "‚õÖ";
  return "‚òÅÔ∏è";
}

// Header day labels come from API daily.time (not phone clock)
function setHeaderDaysFromTimes(times){
  const dayEls = grid.querySelectorAll(".day");
  for(let i=0;i<dayEls.length;i++){
    const iso = times?.[i];
    if(!iso) continue;
    const d = new Date(iso + "T12:00:00");
    dayEls[i].textContent = d.toLocaleDateString(undefined,{weekday:'short'});
  }
}

/* ---------------- state so typing doesn't get nuked ---------------- */
let currentN = null;
const rows = [];

function clearGrid(){ grid.innerHTML = ""; }

function makePlaceholder(i){
  if(i === 1) return "City 1";
  if(i === 2) return "City 2 (optional)";
  return `City ${i} (optional)`;
}

function formatPlace(g){
  const name = g?.name || "";
  const admin1 = g?.admin1 || "";
  const cc = g?.country_code || "";
  if(!name) return "";
  if(cc === "US"){
    return admin1 ? `${name}, ${admin1}` : name;
  }
  const parts = [name];
  if(admin1) parts.push(admin1);
  if(cc) parts.push(cc);
  return parts.join(", ");
}

function setSampleCell(cell){
  cell.innerHTML = `
    <div class="sampleStamp">${currentN}-day sample</div>
    <div style="color:#9ca3af;font-weight:800;">‚Äî</div>
  `;
}

function buildStructure(n){
  clearGrid();
  updateTitle(n);

  // header row placeholders
  grid.appendChild(document.createElement("div"));
  for(let i=0;i<n;i++){
    const el = document.createElement("div");
    el.className = "day";
    el.textContent = "‚Äî";
    grid.appendChild(el);
  }

  rows.length = 0;

  for(let i=1;i<=5;i++){
    const city = document.createElement("div");
    city.className="cityWrap";
    city.innerHTML=`
      <input class="cityInput" list="cities" placeholder="${makePlaceholder(i)}" spellcheck="false" autocapitalize="words">
      <div class="cityConfirm"></div>
      <div class="cityLink"></div>
    `;
    grid.appendChild(city);

    const cells=[];
    for(let d=0; d<n; d++){
      const c=document.createElement("div");
      c.className="cell";
      grid.appendChild(c);
      setSampleCell(c);
      cells.push(c);
    }

    const input = city.querySelector(".cityInput");
    const confirm = city.querySelector(".cityConfirm");
    const link = city.querySelector(".cityLink");

    const rowState = { input, confirm, link, cells, place:null, wx:null };

    // Autocomplete + live ‚Äúguess‚Äù line
    let debounce;
    input.addEventListener("input",()=>{
      clearTimeout(debounce);
      const q = input.value.trim();
      if(q.length < 2) return;
      debounce = setTimeout(async()=>{
        const res = await geocode(q);
        datalist.innerHTML="";
        res.forEach(r=>{
          const o=document.createElement("option");
          o.value=r.name;
          datalist.appendChild(o);
        });
        if(res.length){
          confirm.textContent = formatPlace(res[0]);
        }
      }, 220);
    });

    input.addEventListener("change", async()=>{
      const q=input.value.trim();
      if(!q) return;

      const res=await geocode(q);
      if(!res.length) return;

      const g=res[0];
      rowState.place = g;

      input.value = g.name;
      confirm.textContent = formatPlace(g);
      link.innerHTML = `üìç <a target="_blank" rel="noopener"
        href="https://www.google.com/search?q=${encodeURIComponent("things to do in " + g.name)}">
        Things to do in ${g.name}</a>`;

      rowState.wx = await forecast(g.latitude, g.longitude, currentN);
      renderRow(rowState);
    });

    rows.push(rowState);
  }
}

function renderRow(row){
  if(!row.wx || !row.wx.daily || !row.wx.hourly) return;

  const n = currentN;

  // Build day map once per forecast
  row.wx.__dayMap = row.wx.__dayMap || groupHourlyByDay(row.wx);

  // Header days from API (first loaded city sets them)
  if(!renderRow.__headerSet){
    setHeaderDaysFromTimes(row.wx.daily.time);
    renderRow.__headerSet = true;
  }

  for(let d=0; d<n; d++){
    const dayISO = row.wx.daily.time[d];

    // representative hour (1pm local) for icon accuracy
    const repIdx = pickRepHourIndex(row.wx, dayISO);

    const codeH = repIdx != null ? row.wx.hourly.weather_code[repIdx] : 0;
    const cloud = repIdx != null ? row.wx.hourly.cloud_cover[repIdx] : null;
    const pProb = repIdx != null ? row.wx.hourly.precipitation_probability[repIdx] : null;
    const pMm   = repIdx != null ? row.wx.hourly.precipitation[repIdx] : null;
    const isDay = repIdx != null ? (row.wx.hourly.is_day?.[repIdx] ?? 1) : 1;

    const icon = wxIconFromHourly(codeH, cloud, pMm, pProb, isDay);

    // Wind accuracy: "typical daytime sustained" + daytime max gust
    const idxs = row.wx.__dayMap.get(dayISO) || [];
    const dayIdxs = idxs.filter(i => row.wx.hourly.is_day?.[i] === 1);
    const useIdxs = dayIdxs.length ? dayIdxs : idxs;

    const sustArr = useIdxs.map(i => row.wx.hourly.windspeed_10m[i]).filter(v => v != null);
    const gustArr = useIdxs.map(i => row.wx.hourly.windgusts_10m[i]).filter(v => v != null);

    const windSust = mph(median(sustArr) ?? 0);
    const gustMax  = mph((gustArr.length ? Math.max(...gustArr) : windSust));

    const color = windColor(windSust);
    const gusty = isGusty(windSust, gustMax);

    row.cells[d].innerHTML = `
      <div class="wxIcon">${icon}</div>
      <div class="windRow">
        <span class="windIcon" style="color:${color}">${windSVG}</span>
        <span class="windNum">${windSust}</span>
        ${gusty ? '<span class="gustTri" title="Gusty (gusts ‚â• 1.8√ó sustained)"></span>' : ''}
      </div>
      <div class="hi">${Math.round(row.wx.daily.temperature_2m_max[d])}¬∞</div>
      <div class="lo">${Math.round(row.wx.daily.temperature_2m_min[d])}¬∞</div>
    `;
  }
}

/* Rebuild ONLY when day count changes (portrait 3 ‚Üî landscape 7) */
async function rebuildIfNeeded(){
  const n = daysCount();
  if(currentN === n) return;

  // snapshot typing + resolved place
  const snapshot = rows.map(r=>({ typed:r.input?.value||"", place:r.place }));

  currentN = n;
  buildStructure(n);

  // allow header to reset (new grid)
  renderRow.__headerSet = false;

  // restore inputs + resolved places (refetch)
  snapshot.forEach((s, idx)=>{
    const r = rows[idx];
    if(!r) return;
    r.input.value = s.typed || "";

    if(s.place){
      r.place = s.place;
      r.confirm.textContent = formatPlace(s.place);
      r.link.innerHTML = `üìç <a target="_blank" rel="noopener"
        href="https://www.google.com/search?q=${encodeURIComponent("things to do in " + s.place.name)}">
        Things to do in ${s.place.name}</a>`;

      forecast(s.place.latitude, s.place.longitude, currentN).then(wx=>{
        r.wx = wx;
        renderRow(r);
      });
    }
  });
}

/* init */
currentN = daysCount();
buildStructure(currentN);

/* orientation change triggers day-count changes cleanly */
const mq = matchMedia("(orientation:landscape)");
mq.addEventListener?.("change", rebuildIfNeeded);
mq.addListener?.(rebuildIfNeeded);

// guarded resize (debounced) for edge cases
window.addEventListener("resize", ()=>{
  clearTimeout(window.__wbResizeT);
  window.__wbResizeT = setTimeout(rebuildIfNeeded, 140);
});
</script>
